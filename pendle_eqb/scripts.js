let EQB_PENDLE_BOOSTER;
let EQBPoolDetails = saved_eqb_pools;
let EQBPoolLength;
let EQBPoolLength_local;
let EQB_pool_local_last_updated;
let printAll = false;

// force: must update even the EQBPoolLength > 0
async function updateEQBPendleBooster(force = false) {
    EQBPoolLength_local = saved_eqb_pools.length;
    EQB_pool_local_last_updated = formatDateOnly(saved_eqb_pools_updated_at)
    if (!force && EQB_PENDLE_BOOSTER && EQBPoolLength !== 0) {
        return;
    }
    EQB_PENDLE_BOOSTER = new ethers.Contract(EQB_PENDLE_BOOSTER_ADDRESS, abi_iequilibria_pendle_booster_mainchain, RPC_PROVIDER_ETH);
    EQBPoolLength = await EQB_PENDLE_BOOSTER.poolLength();
}

async function getEQBPoolInfoByPids(pids) {
    // Batch 1: poolInfo
    const poolInfoCalls = pids.map(pid => ({
        contract: EQB_PENDLE_BOOSTER,
        method: "poolInfo",
        params: [pid]
    }));
    const poolInfos = await executeMulticall(RPC_PROVIDER_ETH, poolInfoCalls);

    // Filter valid poolInfos
    const validPoolInfos = poolInfos.map((info, idx) => ({ info, pid: pids[idx] })).filter(x => x.info);
    if (validPoolInfos.length === 0) return [];

    // Batch 2: readTokens and expiry
    const marketCalls = [];
    validPoolInfos.forEach(({ info }) => {
        const ipMarketContract = new ethers.Contract(info.market, abi_ipmarket, RPC_PROVIDER_ETH);
        marketCalls.push({ contract: ipMarketContract, method: "readTokens" });
        marketCalls.push({ contract: ipMarketContract, method: "expiry" });
    });

    const marketResults = await executeMulticall(RPC_PROVIDER_ETH, marketCalls);

    // Batch 3: SY symbol
    const syCalls = [];
    const validMarketResults = [];
    
    for (let i = 0; i < validPoolInfos.length; i++) {
        const readTokens = marketResults[i * 2];
        const expiry = marketResults[i * 2 + 1];
        
        if (!readTokens || !expiry) continue;
        
        const [SY, PT, YT] = readTokens;
        const sy = new ethers.Contract(SY, abi_erc20metadata, RPC_PROVIDER_ETH);
        syCalls.push({ contract: sy, method: "symbol" });
        
        validMarketResults.push({
            pid: validPoolInfos[i].pid,
            poolInfo: validPoolInfos[i].info,
            SY, PT, YT,
            expiry
        });
    }
    
    if (validMarketResults.length === 0) return [];

    const syResults = await executeMulticall(RPC_PROVIDER_ETH, syCalls);

    return validMarketResults.map((data, idx) => {
        const sysymbol = syResults[idx];
        const expiryFormatted = formatDateOnly(data.expiry);
        return {
            "eqb_pid": data.pid,
            "pendle_lpt": data.poolInfo.market,
            "pendle_lpt_expiry": expiryFormatted,
            "sy_symbol": sysymbol,
            "pendle_SY": data.SY,
            "pendle_PT": data.PT,
            "pendle_YT": data.YT,
            "eqb_token": data.poolInfo.token,
            "eqb_reward_pool": data.poolInfo.rewardPool
        };
    });
}

function saveEQBPoolsResultAsJSONFile(output) {
    const timestamp = Math.floor(Date.now()/1000);
    const blob = new Blob([output], { type: 'application/javascript' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `saved_eqb_pools_${timestamp}.json`;
    link.click();
}

function saveEQBPoolsResultAsJSFile(output) {
    const timestamp = Math.floor(Date.now()/1000);
    const jsContent = `// generated by: https://0xvanfer.github.io/protocol_tools/pendle_eqb/eqb_pools.html
const saved_eqb_pools = ${output};

const saved_eqb_pools_updated_at = ${timestamp};`;

    const blob = new Blob([jsContent], { type: 'application/javascript' });

    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'saved_eqb_pools.js';
    link.click();
}

function formatEQBPoolJSON2Output(info, printAll = true){
    let output = "";
    output += `  {\n`;
    output += `    "eqb_pid": "${info.eqb_pid}",\n`;
    output += `    "pendle_lpt": "${info.pendle_lpt}",\n`;
    output += `    "pendle_lpt_expiry": "${info.pendle_lpt_expiry}",\n`;
    if (printAll){
        output += `    "sy_symbol": "${info.sy_symbol}",\n`;
        output += `    "pendle_SY": "${info.pendle_SY}",\n`;
        output += `    "pendle_PT": "${info.pendle_PT}",\n`;
        output += `    "pendle_YT": "${info.pendle_YT}",\n`;
        output += `    "eqb_token": "${info.eqb_token}",\n`;
    }
    output += `    "eqb_reward_pool": "${info.eqb_reward_pool}"\n`;
    output += `  }`;
    return output;
}

async function updateEQBPendleDetails(forceUpdatePoolLength, printDetails){
    await updateEQBPendleBooster(forceUpdatePoolLength)

    if (!printDetails && EQBPoolLength == EQBPoolDetails.length){
        return 
    }

    let maxPools = EQBPoolLength;
    let startID = EQBPoolDetails.length;

    let output = `[\n`;
    for (let i = 0; i < startID; i++) {
        const info = EQBPoolDetails[i];
        output += formatEQBPoolJSON2Output(info, true);
        if (i < startID - 1) output += `,\n`;
    }

    if (startID > 0) {
        if (startID < maxPools) output += `,`;
        output += `\n`;
    }

    if (printDetails) setElementValueAndScrollDown("output", output);

    const BATCH_SIZE = 10;
    for (let i = startID; i < maxPools; i += BATCH_SIZE) {
        const pids = [];
        for (let j = i; j < Math.min(i + BATCH_SIZE, maxPools); j++) {
            pids.push(j);
        }
        
        setElementValueAndScrollDown("output", `Fetching pools ${pids[0]} to ${pids[pids.length-1]}...`);
        const newPools = await getEQBPoolInfoByPids(pids);
        
        // Sort by PID just in case
        newPools.sort((a, b) => a.eqb_pid - b.eqb_pid);

        newPools.forEach(poolInfoJSON => {
             output += formatEQBPoolJSON2Output(poolInfoJSON, true);
             EQBPoolDetails.push(poolInfoJSON);
             const isLast = (poolInfoJSON.eqb_pid === maxPools - 1);
             if (!isLast) output += `,`;
             output += `\n`;
        });
        
        if (printDetails) setElementValueAndScrollDown("output", output);
    }

    output += `]`;
    if (printDetails) setElementValueAndScrollDown("output", output + "\n");
    return output
}